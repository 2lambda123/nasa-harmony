#!/bin/bash

set -e

SELF=$(basename $0)

function usage
{
  echo "Usage: $SELF [-c|--context <kubernetes-context>] [-d|--driver <driver>] [port]"

  echo "port must be a number"
}

CREATE=false

while [[ $# -gt 0 ]]
do
key="$1"

case $key in
  -d|--driver)
  DRIVER=$2
  shift
  shift
  ;;
  -c|--context)
  KUBE_CONTEXT=$2
  shift
  shift
  ;;
  *)
  PPORT="$1"
  shift
  ;;
esac
done


# use docker driver as the default
DRIVER_DEFAULT=docker

DRIVER=${DRIVER:-$DRIVER_DEFAULT}

source ".service-images"
source ".env"
[[ -n $KUBERNETES_URL ]] && alias kubectl="kubectl -s $KUBERNETES_URL"

if [ -n "$KUBE_CONTEXT" ]; then :
elif kubectl config get-contexts docker-desktop &> /dev/null ; then
  KUBE_CONTEXT='docker-desktop'
elif command -v minikube &> /dev/null ; then
  KUBE_CONTEXT='minikube'
else
  echo 'ERROR: Could not find an available Kubernetes context.' >&2
  echo 'If you are using Docker Desktop, make sure it is running and Kubernetes is enabled.' >&2
  echo 'If you are using minikube, make sure it is installed and in your PATH.' >&2
  echo 'If you are using another Kubernetes, specify its context using --context.' >&2
  exit 1
fi

PORT=${PPORT:-2746}

[[ $PORT =~ ^[0-9]+$ ]] || (usage && exit 1)

echo "Using Kubernetes context \"$KUBE_CONTEXT\""

if [[ "$KUBE_CONTEXT" == "minikube" ]]; then
  echo "Starting minikube using driver \"$DRIVER\""

  minikube start --driver="$DRIVER"

  sleep 5
fi
kubectl config use-context $KUBE_CONTEXT

argo_namespace=$(kubectl get namespace | grep argo | cut -d ' ' -f1)

if [ -z "$argo_namespace" ]; then
  kubectl create namespace argo
fi

STAGING_BUCKET=${STAGING_BUCKET:-local-staging-bucket}
ARTIFACT_BUCKET=${ARTIFACT_BUCKET:-local-artifact-bucket}
UPLOAD_BUCKET=${UPLOAD_BUCKET:-local-upload-bucket}

localstack_startup_script="
awslocal s3 mb s3://${STAGING_BUCKET}
awslocal s3 mb s3://${ARTIFACT_BUCKET}
awslocal s3 mb s3://${UPLOAD_BUCKET}"

kubectl -n argo delete configmap localstack-config 2>/dev/null || true
kubectl -n argo create configmap localstack-config --from-literal=startup.sh="${localstack_startup_script}"

cat <<EOF | kubectl -n argo apply -f -
apiVersion: v1
kind: ConfigMap
metadata:
  name: harmony-env
data:
  AWS_DEFAULT_REGION: "${AWS_DEFAULT_REGION}"
  USE_LOCALSTACK: "${USE_LOCALSTACK}"
  STAGING_BUCKET: "${STAGING_BUCKET}"
  STAGING_PATH: "${STAGING_PATH}"
  TEXT_LOGGER: "${TEXT_LOGGER}"
  BACKEND_HOST: "${BACKEND_HOST}"
  OAUTH_HOST: "${OAUTH_HOST}"
  OAUTH_CLIENT_ID: "${OAUTH_CLIENT_ID}"
  OAUTH_REDIRECT_URI: "${OAUTH_REDIRECT_URI}"
  FALLBACK_AUTHN_ENABLED: "${FALLBACK_AUTHN_ENABLED}"
EOF

cat <<EOF | kubectl -n argo apply -f -
apiVersion: v1
kind: Secret
metadata:
  name: harmony-secrets
type: Opaque
data:
  OAUTH_UID: $(echo -n "${OAUTH_UID}" | base64)
  OAUTH_PASSWORD: $(echo -n "${OAUTH_PASSWORD}" | base64)
  EDL_USERNAME: $(echo -n "${EDL_USERNAME}" | base64)
  EDL_PASSWORD: $(echo -n "${EDL_PASSWORD}" | base64)
  SHARED_SECRET_KEY: $(echo -n "${SHARED_SECRET_KEY}" | base64)
EOF

kubectl apply -n argo -f ./config/local-argo-deployment.yml


[[ $USE_LOCALSTACK = 'true' ]] && s3_endpoint="localstack:4572" || s3_endpoint="s3.amazonaws.com"

# In deployed environments, we also want "useSDKCreds: true" in the s3 block
kubectl -n argo patch \
  configmap/workflow-controller-configmap \
  --patch "$(cat << EOF
data:
  artifactRepository: |
    archiveLogs: true
    s3:
      bucket: ${ARTIFACT_BUCKET}
      endpoint: "${s3_endpoint}"
      keyFormat: artifacts/{{workflow.name}}/{{pod.name}}
      insecure: true
      accessKeySecret:
        name: localstack-creds
        key: accessKey
      secretKeySecret:
        name: localstack-creds
        key: secretKey
EOF
)"

# wait for argo to start up
while [[ $(kubectl -n argo get pods -l app=argo-server -o 'jsonpath={..status.conditions[?(@.type=="Ready")].status}') != "True" ]]; do echo "waiting for argo" && sleep 5; done

function install_template {
  f=$1
  echo "Installing template ${f}"
  workflow=$(basename $f .yaml)
  existing_workflow=$(argo -n argo template get $workflow 2>/dev/null | grep $workflow | cut -d ' ' -f1)
  if [ -n "$existing_workflow" ]; then
    argo -n argo template delete $workflow
  fi
  argo -n argo template create $f
}

function create_batch_template {
  f=$1
  workflow=$(basename $f .yaml)
  new_template_name="${workflow}-batch"
  template=$(cat ./config/base-workflow-templates/batch-skeleton.yaml)
  template="${template//\<placeholder-template-steps\>/${workflow}-steps}"
  template="${template//\<placeholder-template\>/${workflow}}"
  template="${template//\<batch-skeleton\>/${new_template_name}}"
  out_file="/tmp/${new_template_name}.yaml"
  echo "${template}" > "${out_file}"
  echo "${out_file}"
}

function parameterize_template {
  f=$1
  workflow=$(basename $f .yaml)
  new_template_name="${workflow}-chain"
  template=$(cat ./config/base-workflow-templates/chained-workflow-skeleton.yaml)
  template="${template//\<placeholder-template\>/${workflow}-batch}"
  template="${template//\<chained-workflow-skeleton\>/${new_template_name}}"
  out_file="/tmp/${new_template_name}.yaml"
  echo "${template}" > "${out_file}"
  echo "${out_file}"
}

# set the `image` for a container definition in a workflow using the images defined in
# .service-images
function inject_docker_image {
  f=$1
  workflow=$(basename $f .yaml)
  image_key="${workflow//-/_}_image"
  image=${!image_key}
  new_template_path="/tmp/${workflow}.yaml"
  raw_template=$(cat $f)
  new_template="${raw_template//\<DOCKER_IMAGE\>/${image}}"
  echo "${new_template}" > "${new_template_path}"
  echo "${new_template_path}"
}

for f in ./config/workflow-component-templates/*; do
  install_template $f
done

for f in ./config/workflow-templates/*; do
  batch_file=$(create_batch_template $f)
  chain_file=$(parameterize_template $f)
  workflow_file=$(inject_docker_image $f)
  
  install_template $workflow_file
  install_template $batch_file
  install_template $chain_file
done

if [[ "$KUBE_CONTEXT" == "minikube" ]]; then
  # Allow LoadBalancer services to be reached in minikube
  minikube tunnel
fi

echo ''
echo 'Complete!'
echo ''
echo 'Localstack has started at http://localhost:4566/'
echo 'Argo has started at http://localhost:2746/'
echo 'Run `kubectl delete namespaces argo` to remove all local resources or run this script again to re-deploy'
