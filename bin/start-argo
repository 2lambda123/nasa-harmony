#!/bin/bash

set -e

SELF=$(basename $0)

function usage
{
  echo "Usage: $SELF [-c|--context <kubernetes-context>] [-d|--driver <driver>] [port]"

  echo "port must be a number"
}

CREATE=false

while [[ $# -gt 0 ]]
do
key="$1"

case $key in
  -d|--driver)
  DRIVER=$2
  shift
  shift
  ;;
  -c|--context)
  KUBE_CONTEXT=$2
  shift
  shift
  ;;
  *)
  PPORT="$1"
  shift
  ;;
esac
done


# use docker driver as the default
DRIVER_DEFAULT=docker

DRIVER=${DRIVER:-$DRIVER_DEFAULT}

if [ -n "$KUBE_CONTEXT" ]; then :
elif kubectl config get-contexts docker-desktop &> /dev/null ; then
  KUBE_CONTEXT='docker-desktop'
elif command -v minikube &> /dev/null ; then
  KUBE_CONTEXT='minikube'
else
  echo 'ERROR: Could not find an available Kubernetes context.' >&2
  echo 'If you are using Docker Desktop, make sure it is running and Kubernetes is enabled.' >&2
  echo 'If you are using minikube, make sure it is installed and in your PATH.' >&2
  echo 'If you are using another Kubernetes, specify its context using --context.' >&2
  exit 1
fi

source ".env"

PORT=${PPORT:-2746}

[[ $PORT =~ ^[0-9]+$ ]] || (usage && exit 1)

echo "Using Kubernetes context \"$KUBE_CONTEXT\""

if [[ "$KUBE_CONTEXT" == "minikube" ]]; then
  echo "Starting minikube using driver \"$DRIVER\""

  minikube start --driver="$DRIVER"

  sleep 5
fi
kubectl config use-context $KUBE_CONTEXT

argo_namespace=$(kubectl get namespace | grep argo | cut -d ' ' -f1)

if [ -z "$argo_namespace" ]; then
  kubectl create namespace argo
fi

cat <<EOF | kubectl -n argo apply -f -
apiVersion: v1
kind: Secret
metadata:
  name: argo-edl-credentials
type: Opaque
data:
  username: $(echo -n "${EDL_USERNAME}" | base64)
  password: $(echo -n "${EDL_PASSWORD}" | base64)
EOF

cat <<EOF | kubectl -n argo apply -f -
apiVersion: v1
kind: Secret
metadata:
  name: shared-secret
type: Opaque
data:
  secret-key: $(echo -n "${SHARED_SECRET_KEY}" | base64)
EOF

kubectl apply -n argo -f ./config/local-argo-deployment.yml

# wait for argo to start up
while [[ $(kubectl -n argo get pods -l app=argo-server -o 'jsonpath={..status.conditions[?(@.type=="Ready")].status}') != "True" ]]; do echo "waiting for argo" && sleep 5; done

for f in ./config/workflow-templates/*; do
  workflow=$(basename $f .yaml)
  existing_workflow=$(argo -n argo template get $workflow | grep $workflow | cut -d ' ' -f1)
  if [ -n "$existing_workflow" ]; then
    argo -n argo template delete $workflow
  fi
  argo -n argo template create $f
done

kubectl -n argo port-forward deployment/argo-server "$PORT:2746"
