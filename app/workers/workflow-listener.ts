import * as k8s from '@kubernetes/client-node';
import { Logger } from 'winston';
import Worker from './worker';

export interface Cluster {
  name: string;
  server: string;
}

export interface Context {
  name: string;
  cluster: Cluster;
}

// types of events generated by workflows
export enum EventType {
  ADDED = 'ADDED',
  MODIFIED = 'MODIFIED',
  DELETED = 'DELETED',
  BOOKMARK = 'BOOKMARK',
}

export interface WorkflowListenerConfig {
  // The type of event to listen for
  eventType?: EventType;
  // Regex matching the `reason` field of the event
  reasonRegex?: string;
  // Regex matching the `message` field of the event
  messageRegex?: string;

  namespace: string;

  cluster?: Cluster;

  context?: Context;

  logger: Logger;

}

interface Abortable {
  abort(): void;
}

export interface WorkflowEvent {
  kind: 'Event';
  metadata:
  {
    name: string;
    namespace: string;
    uid: string;
    creationTimestamp: string;
  };
  involvedObject:
  {
    kind: 'Workflow';
    namespace: string;
    name: string;
    uid: string;
  };
  reason: string;
  message: string;
  firstTimestamp: string;
  lastTimestamp: string;
  count: number;
  type: string;
}

/**
 * Listens for workflow events matching a pattern and calls a callback when a matching event
 * is encountered
 */
export abstract class WorkflowListener implements Worker {
  watcher: Abortable;

  cluster: Cluster;

  context: Context;

  reasonRegex: RegExp;

  messageRegex: RegExp;

  eventType: EventType;

  namespace: string;

  logger: Logger;

  constructor(config: WorkflowListenerConfig) {
    this.reasonRegex = new RegExp(config.reasonRegex);
    this.messageRegex = new RegExp(config.messageRegex);
    this.eventType = config.eventType;
    this.cluster = config.cluster;
    this.context = config.context;
    this.namespace = config.namespace;
    this.logger = config.logger;
  }

  async abstract eventCallback(event: WorkflowEvent): Promise<void>;

  async start(): Promise<void> {
    const kc = new k8s.KubeConfig();
    if (this.cluster) {
      kc.loadFromOptions({
        clusters: [this.cluster],
        contexts: [this.context],
        currentContext: this.context.name,
      });
    } else {
      kc.loadFromDefault();
    }

    const watch = new k8s.Watch(kc);
    this.watcher = await watch.watch('/api/v1/events',
      // optional query parameters can go here
      {
        allowWatchBookmarks: true,
        namespaced: this.namespace,
      },
      // this callback is called for each received object
      (type, event) => {
        if (type === this.eventType
          && this.reasonRegex.test(event.reason)
          && this.messageRegex.test(event.message)) {
          this.eventCallback(event);
        }
      },
      // this callback is called if the listener terminates
      (err) => {
        this.logger.error(err);
      });
  }

  async stop(): Promise<void> {
    this.watcher?.abort();
  }
}
