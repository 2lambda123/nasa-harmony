import * as k8s from '@kubernetes/client-node';
import { Logger } from 'winston';
import { Worker, Abortable } from './worker';

export interface Cluster {
  name: string;
  server: string;
}

export interface Context {
  name: string;
  cluster: Cluster;
}

// types of events generated by workflows
export enum EventType {
  ADDED = 'ADDED',
  MODIFIED = 'MODIFIED',
  DELETED = 'DELETED',
  BOOKMARK = 'BOOKMARK',
}

export interface WorkflowListenerConfig {
  // The type of event to listen for
  eventType?: EventType;
  // Regex matching the `reason` field of the event
  reasonRegex?: string;
  // Regex matching the `message` field of the event
  messageRegex?: string;

  namespace: string;

  cluster?: Cluster;

  context?: Context;

  logger: Logger;

}

export interface WorkflowEvent {
  kind: string;
  metadata:
  {
    name: string;
    namespace: string;
    uid: string;
    creationTimestamp: string;
  };
  involvedObject:
  {
    kind: string;
    namespace: string;
    name: string;
    uid: string;
  };
  reason: string;
  message: string;
  firstTimestamp: string;
  lastTimestamp: string;
  count: number;
  type: string;
}

/**
 * Listens for workflow events matching a pattern and calls a callback when a matching event
 * is encountered
 */
export abstract class WorkflowListener implements Worker {
  watcher: Abortable;

  cluster: Cluster;

  context: Context;

  reasonRegex: RegExp;

  messageRegex: RegExp;

  eventType: EventType;

  namespace: string;

  logger: Logger;

  constructor(config: WorkflowListenerConfig) {
    this.reasonRegex = new RegExp(config.reasonRegex);
    this.messageRegex = new RegExp(config.messageRegex);
    this.eventType = config.eventType;
    this.cluster = config.cluster;
    this.context = config.context;
    this.namespace = config.namespace;
    this.logger = config.logger;
  }

  /**
   * Handle an argo workflow event
   * @param event - The workflow event to handle
   */
  async abstract handleEvent(event: WorkflowEvent): Promise<void>;

  /**
   * Filter to determine if this listener should handle the given event
   * @param type - Event type
   * @param event - the workflow event
   */
  shouldHandleEvent(type: string, event: WorkflowEvent): boolean {
    return type === this.eventType
      && this.reasonRegex.test(event.reason)
      && this.messageRegex.test(event.message);
  }

  async start(): Promise<void> {
    this.logger.info('Starting workflow listener');
    const kc = new k8s.KubeConfig();
    if (this.cluster) {
      kc.loadFromOptions({
        clusters: [this.cluster],
        contexts: [this.context],
        currentContext: this.context.name,
      });
    } else {
      kc.loadFromDefault();
    }

    const watch = new k8s.Watch(kc);
    this.watcher = await watch.watch('/api/v1/events',
      // optional query parameters can go here
      {
        allowWatchBookmarks: true,
        namespaced: this.namespace,
      },
      // this callback is called for each received object
      async (type, event) => {
        if (this.shouldHandleEvent(type, event)) {
          try {
            await this.handleEvent(event);
          } catch (e) {
            this.logger.warn('Failed to handle workflow event');
            this.logger.warn(e);
          }
        }
      },
      // this callback is called if the listener terminates
      (err) => {
        this.logger.error('Workflow listener has terminated');
        this.logger.error(err);
        setTimeout(async () => { await this.start(); }, 30000);
      });
  }

  async stop(): Promise<void> {
    this.watcher?.abort();
  }
}
